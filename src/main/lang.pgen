#header
%
  #include "src/language/language.hpp"
%


#source
%
  #include <memory>
  #include <vector>
  #include <string_view>
  #include <sstream>

  using namespace std;
  using namespace language;

  template<typename T>
  vector<T> singletonVec(T&& item) {
    vector<T> v;
    v.push_back(move(item));
    return v;
  }

  string_view removeQuotes(string_view sv) {
    return sv.substr(1,sv.size() - 2);
  }

  char maybeEscape(string_view str) {
    if (str[0] == '\\') {
      switch (str[1]) {
        case 'n': return '\n';
        case 't': return '\t';
        default: return str[1];
      }
    }
    return str[0];
  }

  long stolThrow(string_view str, size_t* idx, int base, size_t line) {
    try {
      return stol(string(str), idx, base);
    } catch (const logic_error&) {
      ostringstream err;
      err << "Lexer \033[1;31merror\033[0m on line " << line << ": "
          << str << " is out of range of any integral type";
      throw parser::ParseException(err.str());
    }
  }
%


#tokens

#skip       "//[^\n]*\n"
#skip       "[ \t\n]+"

IF          "if"
ELSE        "else"
WHILE       "while"
FOR         "for"
RETURN      "return"

PLUS        "\+"
MINUS       "-"
STAR        "\*"
FSLASH      "/"
MOD         "%"
BITAND      "&"
BITOR       "\|"
XOR         "^"
LSHIFT      "<<"
ARSHIFT     ">>"

PLUSEQ      "\+="
MINUSEQ     "-="
STAREQ      "\*="
FSLASHEQ    "/="
MODEQ       "%="
BITANDEQ    "&="
BITOREQ     "\|="
XOREQ       "^="
LSHIFTEQ    "<<="
ARSHIFTEQ   ">>="
INC         "\+\+"
DEC         "--"

AND         "&&"
OR          "\|\|"
EQEQ        "=="
NEQ         "!="
LT          "<"
GT          ">"
LTE         "<="
GTE         ">="
BANG        "!"

SEMI        ";"
COMMA       ","
COLON       ":"
QMARK       "\?"
EQ          "="

LBRACE      "{"
RBRACE      "}"
LPAREN      "\("
RPAREN      "\)"
LBRACKET    "\["
RBRACKET    "\]"
LRBRACKET   "\[\]"

TRUE        "true"
FALSE       "false"

VOID        "void"
LONG        "long"
INT         "int"
SHORT       "short"
CHAR        "char"
BOOL        "bool"

IMPORT      "import"
COLON2      "::"

CLASS       "class"
DOT         "\."

PRINT       "print"

NUM         "0|[1-9][0-9]*"                        -> { long }    % stolThrow(#str, nullptr, 10, #line) %
HEXNUM      "0x([0-9]|[A-F]|[a-f])+"               -> { long }    % stolThrow(#str, nullptr, 16, #line) %
IDENT       "([a-z]|[A-Z])(_|[a-z]|[A-Z]|[0-9])*"  -> { string }  % #str %
SRCFILE     "\"([^\n]*/)*[^\n]+\.prez\""           -> { string }  % removeQuotes(#str) %
CHARLIT     "'(.|\\t|\\n)'"                        -> { char }    % maybeEscape(removeQuotes(#str)) %

#prec

// Not an actual operator, just so that
// we can push_back instead of push_front
// for Params, Exprs, Decls, Imports, etc
EPSILON                           #left

QMARK                             #right
OR                                #left
AND                               #left
XOR                               #left
BITOR                             #left
BITAND                            #left
EQEQ NEQ LT GT LTE GTE            #nonassoc
LSHIFT ARSHIFT                    #left
PLUS MINUS                        #left
STAR FSLASH MOD                   #left
UNARY_MINUS BANG                  #nonassoc
INC DEC PRE_INCDEC                #nonassoc
LPAREN LBRACKET DOT               #left
COLON2                            #left


#grammar

Program -> { language::Program }
  := Imports Decls  % Program(move(#0), move(#1)) %
   | Decls          % Program(vector<Import>(), move(#0)) %

Imports -> { vector<Import> }
  := Import             % singletonVec<Import>(move(#0)) %
   | Imports Import     % (#0.push_back(move(#1)), move(#0)) %

Import -> { Import }
  := IMPORT SRCFILE     % { move(#1), #line } %

Decls -> { vector<DeclPtr> }
  :=              #prec EPSILON   % vector<DeclPtr>() %
   | Decls Decl                   % (#0.push_back(move(#1)), move(#0)) %

Decl -> { DeclPtr }
  := Function                   % move(#0) %
   | CLASS IDENT LBRACE
     ClassElements RBRACE       % make_unique<ClassDecl>(#1, move(#3), #line) %

ClassElements -> { vector<ClassDecl::ClassElem> }
  :=              #prec EPSILON   % vector<ClassDecl::ClassElem>() %
   | ClassElements ClassElement   % (#0.push_back(move(#1)), move(#0)) %

ClassElement -> { ClassDecl::ClassElem }
  := NonVoidType IDENT SEMI
               % ClassDecl::ClassElem{ClassDecl::ClassElem::Type::FIELD, { ClassDecl::Field{move(#0), move(#1), #line } } } %
   | IDENT LPAREN Params RPAREN Block
               % ClassDecl::ClassElem{ClassDecl::ClassElem::Type::CTOR, { Constructor(#0, move(#2), move(#4), #line) } } %
   | Function  % ClassDecl::ClassElem{ClassDecl::ClassElem::Type::METHOD, { move(#0) } } %

Function -> { std::unique_ptr<Func> }
  := NonVoidType IDENT LPAREN Params RPAREN Block   % make_unique<Func>(move(#0), #1, move(#3), move(#5), #line) %
  |  VOID IDENT LPAREN Params RPAREN Block          % make_unique<Func>(TypePtr(voidType), #1, move(#3), move(#5), #line) %

Block -> { std::unique_ptr<Block> }
  := LBRACE Stmts RBRACE   % make_unique<Block>(move(#1), #line) %

Stmts -> { vector<StmtPtr> }
  :=            #prec EPSILON  % vector<StmtPtr>() %
   | Stmts Stmt                % (#0.push_back(move(#1)), move(#0)) %

Stmt -> { StmtPtr }
  := IF LPAREN Expr RPAREN Block                 % make_unique<If>(move(#2), move(#4), make_unique<Block>(vector<StmtPtr>(), #line), #line) %
   | IF LPAREN Expr RPAREN Block ELSE ElseStmt   % make_unique<If>(move(#2), move(#4), move(#6), #line) %
   | WHILE LPAREN Expr RPAREN Block              % make_unique<While>(move(#2), move(#4), #line) %
   | FOR LPAREN VarDecl Expr SEMI
     ForUpdate RPAREN Block                      % make_unique<For>(move(#2), move(#3), move(#5), move(#7), #line) %
   | RETURN SEMI                                 % make_unique<Return>(optional<ExprPtr>(), #line) %
   | RETURN Expr SEMI                            % make_unique<Return>(optional<ExprPtr>(move(#1)), #line) %
   | VarDecl                                     % move(#0) %
   | Block                                       % move(#0) %
   | StmtExpr SEMI                               % make_unique<ExprStmt>(move(#0), #line) %
   | PRINT LPAREN Expr RPAREN SEMI               % make_unique<Print>(move(#2), #line) %
   | UpdateStmt SEMI                             % move(#0) %

VarDecl -> { std::unique_ptr<VarDecl> }
  := NonVoidType IDENT EQ Expr SEMI              % make_unique<VarDecl>(move(#0), #1, move(#3), #line) %

ElseStmt -> { StmtPtr }
  := Block                                       % move(#0) %
   | IF LPAREN Expr RPAREN Block ELSE ElseStmt   % make_unique<If>(move(#2), move(#4), move(#6), #line) %

Expr -> { ExprPtr }
  := NUM                                        % make_unique<ConstInt>(#0, #line) %
   | HEXNUM                                     % make_unique<ConstInt>(#0, #line) %
   | TRUE                                       % make_unique<ConstBool>(true, #line) %
   | FALSE                                      % make_unique<ConstBool>(false, #line) %
   | CHARLIT                                    % make_unique<ConstChar>(#0, #line) %
   | MINUS Expr   #prec UNARY_MINUS             % make_unique<UnaryOp>(move(#1), UOp::NEG, #line) %
   | BANG Expr                                  % make_unique<UnaryOp>(move(#1), UOp::NOT, #line) %
   | Expr PLUS Expr                             % make_unique<BinaryOp>(move(#0), move(#2), BOp::PLUS) %
   | Expr MINUS Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::MINUS) %
   | Expr STAR Expr                             % make_unique<BinaryOp>(move(#0), move(#2), BOp::MUL) %
   | Expr FSLASH Expr                           % make_unique<BinaryOp>(move(#0), move(#2), BOp::DIV) %
   | Expr MOD Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::MOD) %
   | Expr BITAND Expr                           % make_unique<BinaryOp>(move(#0), move(#2), BOp::BIT_AND) %
   | Expr BITOR Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::BIT_OR) %
   | Expr XOR Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::XOR) %
   | Expr LSHIFT Expr                           % make_unique<BinaryOp>(move(#0), move(#2), BOp::LSHIFT) %
   | Expr ARSHIFT Expr                          % make_unique<BinaryOp>(move(#0), move(#2), BOp::ARSHIFT) %
   | Expr AND Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::AND) %
   | Expr OR Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::OR) %
   | Expr EQEQ Expr                             % make_unique<BinaryOp>(move(#0), move(#2), BOp::EQ) %
   | Expr NEQ Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::NEQ) %
   | Expr LT Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::LT) %
   | Expr GT Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::GT) %
   | Expr LTE Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::LTE) %
   | Expr GTE Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::GTE) %
   | Expr QMARK Expr COLON Expr                 % make_unique<TernaryOp>(move(#0), move(#2), move(#4)) %
   | NonVoidType LPAREN Expr RPAREN             % make_unique<Cast>(move(#0), move(#2), #line) %
   | NonVoidType LRBRACKET
     LPAREN Expr RPAREN                         % make_unique<NewArray>(move(#0), move(#3), #line) %
   | NonVoidType LRBRACKET LBRACE Exprs RBRACE  % make_unique<NewArray>(move(#0), move(#3), #line) %
   | StmtExpr                                   % move(#0) %
   | LPAREN Expr RPAREN                         % move(#1) %
   // lvalues
   | IDENT                                      % make_unique<Var>(#0, #line) %
   | Expr LBRACKET Expr RBRACKET                % make_unique<ArrayAccess>(move(#0), move(#2), #line) %
   | Expr DOT IDENT                             % make_unique<MemberAccess>(move(#0), #2, #line) %

ForUpdate -> { StmtPtr }
  := UpdateStmt                                 % move(#0) %
   | StmtExpr                                   % make_unique<ExprStmt>(move(#0), #line) %

UpdateStmt -> { StmtPtr }
   := Expr EQ Expr                              % make_unique<Assign>(move(#0), move(#2)) %
   | Expr PLUSEQ Expr                           % make_unique<Update>(move(#0), BOp::PLUS, move(#2)) %
   | Expr MINUSEQ Expr                          % make_unique<Update>(move(#0), BOp::MINUS, move(#2)) %
   | Expr STAREQ Expr                           % make_unique<Update>(move(#0), BOp::MUL, move(#2)) %
   | Expr FSLASHEQ Expr                         % make_unique<Update>(move(#0), BOp::DIV, move(#2)) %
   | Expr MODEQ Expr                            % make_unique<Update>(move(#0), BOp::MOD, move(#2)) %
   | Expr BITANDEQ Expr                         % make_unique<Update>(move(#0), BOp::BIT_AND, move(#2)) %
   | Expr BITOREQ Expr                          % make_unique<Update>(move(#0), BOp::BIT_OR, move(#2)) %
   | Expr XOREQ Expr                            % make_unique<Update>(move(#0), BOp::XOR, move(#2)) %
   | Expr LSHIFTEQ Expr                         % make_unique<Update>(move(#0), BOp::LSHIFT, move(#2)) %
   | Expr ARSHIFTEQ Expr                        % make_unique<Update>(move(#0), BOp::ARSHIFT, move(#2)) %

StmtExpr -> { ExprPtr }
  := INC Expr     #prec PRE_INCDEC              % make_unique<IncDec>(move(#1), true, true, #line) %
   | DEC Expr     #prec PRE_INCDEC              % make_unique<IncDec>(move(#1), false, true, #line) %
   | Expr INC                                   % make_unique<IncDec>(move(#0), true, false, #line) %
   | Expr DEC                                   % make_unique<IncDec>(move(#0), false, false, #line) %
   | IDENT LPAREN Exprs RPAREN                  % make_unique<CallExpr>(vector<string>(), #0, move(#2), #line) %
   | Qualifiers IDENT LPAREN Exprs RPAREN       % make_unique<CallExpr>(move(#0), #1, move(#3), #line) %
   | Expr DOT IDENT LPAREN Exprs RPAREN         % make_unique<MethodInvocation>(move(#0), #2, move(#4), #line) %

Exprs -> { vector<ExprPtr> }
  :=          % vector<ExprPtr>() %
   | Exprz    % move(#0) %

Exprz -> { vector<ExprPtr> }
  := Expr                           % singletonVec<ExprPtr>(move(#0)) %
   | Exprz COMMA Expr               % (#0.push_back(move(#2)), move(#0)) %

Params -> { vector<pair<TypePtr, string>> }
  :=          % vector<pair<TypePtr, string>>() %
   | Paramz   % move(#0) %

Paramz -> { vector<pair<TypePtr, string>> }
  := Param                            % singletonVec<pair<TypePtr, string>>(move(#0)) %
   | Paramz COMMA Param               % (#0.push_back(move(#2)), move(#0)) %

Param -> { pair<TypePtr, string> }
  := NonVoidType IDENT         % { move(#0), #1 } %

NonVoidType -> { TypePtr }
  := LONG                   % longType %
   | INT                    % intType %
   | SHORT                  % shortType %
   | CHAR                   % charType %
   | BOOL                   % boolType %
   | NonVoidType LRBRACKET  % make_shared<Array>(move(#0)) %
   | IDENT                  % make_shared<Class>(vector<string>(), move(#0)) %
   | Qualifiers IDENT       % make_shared<Class>(move(#0), move(#1)) %

Qualifiers -> { vector<string> }
  := Qualifier               % singletonVec<string>(move(#0)) %
   | Qualifiers Qualifier    % (#0.push_back(move(#1)), move(#0)) %

Qualifier -> { string }
  := IDENT COLON2        % #0 %
