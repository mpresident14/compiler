#header
%
  #include "src/language/language.hpp"
%


#source
%
  #include <memory>
  #include <vector>


  using namespace std;
  using namespace language;

  template<typename T>
  vector<T> singletonVec(T&& item) {
    vector<T> v;
    v.push_back(move(item));
    return v;
  }
%


#tokens

#skip       "//[^\n]*\n"
#skip       "[ \t\n]+"

IF          "if"
ELSE        "else"
WHILE       "while"
RETURN      "return"

PLUS        "\+"
MINUS       "-"
STAR        "\*"
FSLASH      "/"
MOD         "%"
BIT_AND     "&"
BIT_OR      "\|"
XOR         "^"
LSHIFT      "<<"
RSHIFT      ">>"

AND         "&&"
OR          "\|\|"
EQEQ        "=="
NEQ         "!="
LT          "<"
GT          ">"
LTE         "<="
GTE         ">="
BANG        "!"

SEMI        ";"
COMMA       ","
COLON       ":"
QMARK       "\?"
EQ          "="

LBRACE      "{"
RBRACE      "}"
LPAREN      "\("
RPAREN      "\)"
LBRACKET    "\["
RBRACKET    "\]"

TRUE        "true"
FALSE       "false"

VOID        "void"
INT         "int"
BOOL        "bool"

NUM         "0|[1-9][0-9]*"                         -> { int }    % stoi(string(#str)) %
IDENT       "([a-z]|[A-Z])(_|[a-z]|[A-Z]|[0-9])*" -> { string } % #str %

#prec

// Not an actual operator, just so that
// we can push_back instead of push_front
// for Params and Exprs
EPSILON                 #left

QMARK                   #right
OR                      #left
AND                     #left
XOR                     #left
BIT_OR                  #left
BIT_AND                 #left
EQEQ NEQ LT GT LTE GTE  #nonassoc
LSHIFT RSHIFT           #left
PLUS MINUS              #left
STAR FSLASH MOD         #left
UNARY_MINUS BANG        #nonassoc
LBRACKET                #left


#grammar

Program -> { language::Program }
  := Decls  % Program(move(#0)) %

Decls -> { vector<DeclPtr> }
  :=              #prec EPSILON  % vector<DeclPtr>() %
   | Decls Decl                  % (#0.push_back(move(#1)), move(#0)) %

Decl -> { DeclPtr }
  := Type IDENT LPAREN Params RPAREN Block    % make_unique<Func>(move(#0), #1, move(#3), move(#5), #line) %

Block -> { std::unique_ptr<Block> }
  := LBRACE Stmts RBRACE   % make_unique<Block>(move(#1), #line) %

Stmts -> { vector<StmtPtr> }
  :=            #prec EPSILON % vector<StmtPtr>() %
   | Stmts Stmt               % (#0.push_back(move(#1)), move(#0)) %

Stmt -> { StmtPtr }
  := IF LPAREN Expr RPAREN Block              % make_unique<If>(move(#2), move(#4), make_unique<Block>(vector<StmtPtr>(), #line), #line) %
   | IF LPAREN Expr RPAREN Block ELSE Stmt    % make_unique<If>(move(#2), move(#4), move(#6), #line) %
   | WHILE LPAREN Expr RPAREN Block           % make_unique<While>(move(#2), move(#4), #line) %
   | IDENT LPAREN Exprs RPAREN SEMI           % make_unique<CallStmt>(#0, move(#2), #line) %
   | RETURN SEMI                              % make_unique<Return>(optional<ExprPtr>(), #line) %
   | RETURN Expr SEMI                         % make_unique<Return>(optional<ExprPtr>(move(#1)), #line) %
   | LValue EQ Expr SEMI                      % make_unique<Assign>(move(#0), move(#2)) %
   | Type IDENT EQ Expr SEMI                  % make_unique<VarDecl>(move(#0), #1, move(#3), #line) %
   | Block                                    % move(#0) %

Expr -> { ExprPtr }
  := NUM                                      % make_unique<ConstInt>(#0, #line) %
   | TRUE                                     % make_unique<ConstBool>(true, #line) %
   | FALSE                                    % make_unique<ConstBool>(false, #line) %
   | MINUS Expr   #prec UNARY_MINUS           % make_unique<UnaryOp>(move(#1), UOp::NEG, #line) %
   | BANG Expr                                % make_unique<UnaryOp>(move(#1), UOp::NOT, #line) %
   | Expr PLUS Expr                           % make_unique<BinaryOp>(move(#0), move(#2), BOp::PLUS) %
   | Expr MINUS Expr                          % make_unique<BinaryOp>(move(#0), move(#2), BOp::MINUS) %
   | Expr STAR Expr                           % make_unique<BinaryOp>(move(#0), move(#2), BOp::MUL) %
   | Expr FSLASH Expr                         % make_unique<BinaryOp>(move(#0), move(#2), BOp::DIV) %
   | Expr MOD Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::MOD) %
   | Expr BIT_AND Expr                        % make_unique<BinaryOp>(move(#0), move(#2), BOp::BIT_AND) %
   | Expr BIT_OR Expr                         % make_unique<BinaryOp>(move(#0), move(#2), BOp::BIT_OR) %
   | Expr XOR Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::XOR) %
   | Expr LSHIFT Expr                         % make_unique<BinaryOp>(move(#0), move(#2), BOp::LSHIFT) %
   | Expr RSHIFT Expr                         % make_unique<BinaryOp>(move(#0), move(#2), BOp::RSHIFT) %
   | Expr AND Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::AND) %
   | Expr OR Expr                             % make_unique<BinaryOp>(move(#0), move(#2), BOp::OR) %
   | Expr EQEQ Expr                           % make_unique<BinaryOp>(move(#0), move(#2), BOp::EQ) %
   | Expr NEQ Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::NEQ) %
   | Expr LT Expr                             % make_unique<BinaryOp>(move(#0), move(#2), BOp::LT) %
   | Expr GT Expr                             % make_unique<BinaryOp>(move(#0), move(#2), BOp::GT) %
   | Expr LTE Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::LTE) %
   | Expr GTE Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::GTE) %
   | Expr QMARK Expr COLON Expr               % make_unique<TernaryOp>(move(#0), move(#2), move(#4)) %
   | IDENT LPAREN Exprs RPAREN                % make_unique<CallExpr>(#0, move(#2), #line) %
   | Type LBRACKET NUM RBRACKET               % make_unique<NewArray>(move(#0), #2, #line) %
   | LValue                                   % move(#0) %
   | LPAREN Expr RPAREN                       % move(#1) %


LValue -> { ExprPtr }
  := IDENT                        % make_unique<Var>(#0, #line) %
   | Expr LBRACKET NUM RBRACKET   % make_unique<ArrayAccess>(move(#0), #2, #line) %

Exprs -> { vector<ExprPtr> }
  :=          % vector<ExprPtr>() %
   | Exprz    % move(#0) %

Exprz -> { vector<ExprPtr> }
  := Expr                           % singletonVec<ExprPtr>(move(#0)) %
   | Exprz COMMA Expr               % (#0.push_back(move(#2)), move(#0)) %

Params -> { vector<pair<TypePtr, string>> }
  :=          % vector<pair<TypePtr, string>>() %
   | Paramz   % move(#0) %

Paramz -> { vector<pair<TypePtr, string>> }
  := Param                            % singletonVec<pair<TypePtr, string>>(move(#0)) %
   | Paramz COMMA Param               % (#0.push_back(move(#2)), move(#0)) %

Param -> { pair<TypePtr, string> }
  := Type IDENT         % { move(#0), #1 } %

Type -> { TypePtr }
  := INT                      % intType %
   | BOOL                     % boolType %
   | VOID                     % voidType %
   | Type LBRACKET RBRACKET   % make_shared<Array>(move(#0)) %
