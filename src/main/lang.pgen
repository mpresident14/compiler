#header
%
  #include "src/language/language.hpp"
%


#source
%
  #include <memory>
  #include <vector>
  #include <string_view>
  #include <sstream>

  using namespace std;
  using namespace language;

  template<typename T>
  vector<T> singletonVec(T&& item) {
    vector<T> v;
    v.push_back(move(item));
    return v;
  }

  string_view removeQuotes(string_view sv) {
    return sv.substr(1,sv.size() - 2);
  }

  char maybeEscape(string_view str) {
    if (str[0] == '\\') {
      switch (str[1]) {
        case 'n': return '\n';
        case 't': return '\t';
        default: return str[1];
      }
    }
    return str[0];
  }

  long stolThrow(string_view str, size_t* idx, int base, size_t line) {
    try {
      return stol(string(str), idx, base);
    } catch (const logic_error&) {
      ostringstream err;
      err << "Lexer \033[1;31merror\033[0m on line " << line << ": "
          << str << " is out of range of any integral type";
      throw parser::ParseException(err.str());
    }
  }
%


#tokens

#skip       "//[^\n]*\n"
#skip       "[ \t\n]+"

IF          "if"
ELSE        "else"
WHILE       "while"
RETURN      "return"

PLUS        "\+"
MINUS       "-"
STAR        "\*"
FSLASH      "/"
MOD         "%"
BITAND      "&"
BITOR       "\|"
XOR         "^"
LSHIFT      "<<"
ARSHIFT     ">>"

PLUSEQ      "\+="
MINUSEQ     "-="
STAREQ      "\*="
FSLASHEQ    "/="
MODEQ       "%="
BITANDEQ    "&="
BITOREQ     "\|="
XOREQ       "^="
LSHIFTEQ    "<<="
ARSHIFTEQ   ">>="
// INC         "++"
// DEC         "--"

AND         "&&"
OR          "\|\|"
EQEQ        "=="
NEQ         "!="
LT          "<"
GT          ">"
LTE         "<="
GTE         ">="
BANG        "!"

SEMI        ";"
COMMA       ","
COLON       ":"
QMARK       "\?"
EQ          "="

LBRACE      "{"
RBRACE      "}"
LPAREN      "\("
RPAREN      "\)"
LBRACKET    "\["
RBRACKET    "\]"

TRUE        "true"
FALSE       "false"

VOID        "void"
LONG        "long"
INT         "int"
SHORT       "short"
CHAR        "char"
BOOL        "bool"

IMPORT      "import"
COLON2      "::"

DOT         "\."

PRINT       "print"

NUM         "0|[1-9][0-9]*"                        -> { long }    % stolThrow(#str, nullptr, 10, #line) %
HEXNUM      "0x([0-9]|[A-F]|[a-f])+"               -> { long }    % stolThrow(#str, nullptr, 16, #line) %
IDENT       "([a-z]|[A-Z])(_|[a-z]|[A-Z]|[0-9])*"  -> { string }  % #str %
SRCFILE     "\"([^\n]*/)*[^\n]+\.prez\""           -> { string }  % removeQuotes(#str) %
CHARLIT     "'(.|\\t|\\n)'"                        -> { char }    % maybeEscape(removeQuotes(#str)) %

#prec

// Not an actual operator, just so that
// we can push_back instead of push_front
// for Params, Exprs, Decls, Imports, etc
EPSILON1                #left
EPSILON2                #left

QMARK                             #right
OR                                #left
AND                               #left
XOR                               #left
BITOR                             #left
BITAND                            #left
EQEQ NEQ LT GT LTE GTE            #nonassoc
LSHIFT ARSHIFT                    #left
PLUS MINUS                        #left
STAR FSLASH MOD                   #left
UNARY_MINUS BANG                  #nonassoc
LPAREN LBRACKET DOT               #left
COLON2                            #left


#grammar

Program -> { language::Program }
  := Imports Decls  % Program(move(#0), move(#1)) %

Imports -> { vector<Import> }
  :=                #prec EPSILON2 % vector<Import>() %
   | Imports Import                % (#0.push_back(move(#1)), move(#0)) %

Import -> { Import }
  := IMPORT SRCFILE     % { move(#1), #line } %

Decls -> { vector<DeclPtr> }
  :=              #prec EPSILON1  % vector<DeclPtr>() %
   | Decls Decl                   % (#0.push_back(move(#1)), move(#0)) %

Decl -> { DeclPtr }
  := Type IDENT LPAREN Params RPAREN Block    % make_unique<Func>(move(#0), #1, move(#3), move(#5), #line) %

Block -> { std::unique_ptr<Block> }
  := LBRACE Stmts RBRACE   % make_unique<Block>(move(#1), #line) %

Stmts -> { vector<StmtPtr> }
  :=            #prec EPSILON1 % vector<StmtPtr>() %
   | Stmts Stmt                % (#0.push_back(move(#1)), move(#0)) %

Stmt -> { StmtPtr }
  := IF LPAREN Expr RPAREN Block                 % make_unique<If>(move(#2), move(#4), make_unique<Block>(vector<StmtPtr>(), #line), #line) %
   | IF LPAREN Expr RPAREN Block ELSE ElseStmt   % make_unique<If>(move(#2), move(#4), move(#6), #line) %
   | WHILE LPAREN Expr RPAREN Block              % make_unique<While>(move(#2), move(#4), #line) %
   | RETURN SEMI                                 % make_unique<Return>(optional<ExprPtr>(), #line) %
   | RETURN Expr SEMI                            % make_unique<Return>(optional<ExprPtr>(move(#1)), #line) %
   | LValue EQ Expr SEMI                         % make_unique<Assign>(move(#0), move(#2)) %
   | NonVoidType IDENT EQ Expr SEMI              % make_unique<VarDecl>(move(#0), #1, move(#3), #line) %
   | Block                                       % move(#0) %
   | Expr SEMI                                   % make_unique<ExprStmt>(move(#0), #line) %
   | PRINT LPAREN Expr RPAREN SEMI               % make_unique<Print>(move(#2), #line) %
   | LValue PLUSEQ Expr SEMI                     % make_unique<Update>(move(#0), BOp::PLUS, move(#2)) %
   | LValue MINUSEQ Expr SEMI                    % make_unique<Update>(move(#0), BOp::MINUS, move(#2)) %
   | LValue STAREQ Expr SEMI                     % make_unique<Update>(move(#0), BOp::MUL, move(#2)) %
   | LValue FSLASHEQ Expr SEMI                   % make_unique<Update>(move(#0), BOp::DIV, move(#2)) %
   | LValue MODEQ Expr SEMI                      % make_unique<Update>(move(#0), BOp::MOD, move(#2)) %
   | LValue BITANDEQ Expr SEMI                   % make_unique<Update>(move(#0), BOp::BIT_AND, move(#2)) %
   | LValue BITOREQ Expr SEMI                    % make_unique<Update>(move(#0), BOp::BIT_OR, move(#2)) %
   | LValue XOREQ Expr SEMI                      % make_unique<Update>(move(#0), BOp::XOR, move(#2)) %
   | LValue LSHIFTEQ Expr SEMI                   % make_unique<Update>(move(#0), BOp::LSHIFT, move(#2)) %
   | LValue ARSHIFTEQ Expr SEMI                  % make_unique<Update>(move(#0), BOp::ARSHIFT, move(#2)) %

ElseStmt -> { StmtPtr }
  := Block                                      % move(#0) %
   | IF LPAREN Expr RPAREN Block ELSE ElseStmt  % make_unique<If>(move(#2), move(#4), move(#6), #line) %


Expr -> { ExprPtr }
  := NUM                                         % make_unique<ConstInt>(#0, #line) %
   | HEXNUM                                      % make_unique<ConstInt>(#0, #line) %
   | TRUE                                        % make_unique<ConstBool>(true, #line) %
   | FALSE                                       % make_unique<ConstBool>(false, #line) %
   | CHARLIT                                     % make_unique<ConstChar>(#0, #line) %
   | MINUS Expr   #prec UNARY_MINUS              % make_unique<UnaryOp>(move(#1), UOp::NEG, #line) %
   | BANG Expr                                   % make_unique<UnaryOp>(move(#1), UOp::NOT, #line) %
   | Expr PLUS Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::PLUS) %
   | Expr MINUS Expr                             % make_unique<BinaryOp>(move(#0), move(#2), BOp::MINUS) %
   | Expr STAR Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::MUL) %
   | Expr FSLASH Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::DIV) %
   | Expr MOD Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::MOD) %
   | Expr BITAND Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::BIT_AND) %
   | Expr BITOR Expr                             % make_unique<BinaryOp>(move(#0), move(#2), BOp::BIT_OR) %
   | Expr XOR Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::XOR) %
   | Expr LSHIFT Expr                            % make_unique<BinaryOp>(move(#0), move(#2), BOp::LSHIFT) %
   | Expr ARSHIFT Expr                           % make_unique<BinaryOp>(move(#0), move(#2), BOp::ARSHIFT) %
   | Expr AND Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::AND) %
   | Expr OR Expr                                % make_unique<BinaryOp>(move(#0), move(#2), BOp::OR) %
   | Expr EQEQ Expr                              % make_unique<BinaryOp>(move(#0), move(#2), BOp::EQ) %
   | Expr NEQ Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::NEQ) %
   | Expr LT Expr                                % make_unique<BinaryOp>(move(#0), move(#2), BOp::LT) %
   | Expr GT Expr                                % make_unique<BinaryOp>(move(#0), move(#2), BOp::GT) %
   | Expr LTE Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::LTE) %
   | Expr GTE Expr                               % make_unique<BinaryOp>(move(#0), move(#2), BOp::GTE) %
   | Expr QMARK Expr COLON Expr                  % make_unique<TernaryOp>(move(#0), move(#2), move(#4)) %
   | IDENT LPAREN Exprs RPAREN                   % make_unique<CallExpr>(vector<string>(), #0, move(#2), #line) %
   | Qualifiers IDENT LPAREN Exprs RPAREN        % make_unique<CallExpr>(move(#0), #1, move(#3), #line) %
   | LPAREN NonVoidType RPAREN Expr              % make_unique<Cast>(move(#1), move(#3), #line) %
   | NonVoidType LBRACKET Expr RBRACKET          % make_unique<NewArray>(move(#0), move(#2), #line) %
   | NonVoidType LBRACKET RBRACKET
     LBRACE Exprs RBRACE                         % make_unique<NewArray>(move(#0), move(#4), #line) %
   | LValue                                      % move(#0) %
   | LPAREN Expr RPAREN                          % move(#1) %


LValue -> { ExprPtr }
  := IDENT                         % make_unique<Var>(#0, #line) %
   | Expr LBRACKET Expr RBRACKET   % make_unique<ArrayAccess>(move(#0), move(#2), #line) %
   | Expr DOT IDENT                % make_unique<MemberAccess>(move(#0), #2, #line) %

Exprs -> { vector<ExprPtr> }
  :=          % vector<ExprPtr>() %
   | Exprz    % move(#0) %

Exprz -> { vector<ExprPtr> }
  := Expr                           % singletonVec<ExprPtr>(move(#0)) %
   | Exprz COMMA Expr               % (#0.push_back(move(#2)), move(#0)) %

Params -> { vector<pair<TypePtr, string>> }
  :=          % vector<pair<TypePtr, string>>() %
   | Paramz   % move(#0) %

Paramz -> { vector<pair<TypePtr, string>> }
  := Param                            % singletonVec<pair<TypePtr, string>>(move(#0)) %
   | Paramz COMMA Param               % (#0.push_back(move(#2)), move(#0)) %

Param -> { pair<TypePtr, string> }
  := NonVoidType IDENT         % { move(#0), #1 } %

NonVoidType -> { TypePtr }
  := LONG                            % longType %
   | INT                             % intType %
   | SHORT                           % shortType %
   | CHAR                            % charType %
   | BOOL                            % boolType %
   | NonVoidType LBRACKET RBRACKET   % make_shared<Array>(move(#0)) %

Type -> { TypePtr }
  := NonVoidType              % move(#0) %
   | VOID                     % voidType %

Qualifiers -> { vector<string> }
  := Qualifier               % singletonVec<string>(move(#0)) %
   | Qualifiers Qualifier    % (#0.push_back(move(#1)), move(#0)) %

Qualifier -> { string }
  := IDENT COLON2        % #0 %
